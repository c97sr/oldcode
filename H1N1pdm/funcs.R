# Copyright Steven Riley and Eric Lau 2009 (ste.riley@gmail.com)

# This file is part of Steven Riley's Code Library (StRiCoLi).

# AgeStructuredPdmFlu is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# AgeStructuredPdmFlu is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with AgeStructuredPdmFlu.  If not, see <http://www.gnu.org/licenses/>.

require("date")
require("odesolve")
require("seqinr")

LoadCleanCHPData <- function(filename) {
	
	# Designed to take and clean a specific snapshot of data used early in the analysis
	
	#   index  	conf_date 	age 	sex admission  onset    	class 		country infector_index	arrival
	#	1 		01/05/2009  25  	M 	30/04/2009 28/4/2009 	Imported  	Mexico               	30/04/2009
	
	data <- read.csv(filename)
	norecs <- dim(data)[1]
	data[,"conf_date"] <- as.date(as.character(data[,"conf_date"]),order="dmy")
	data[,"admission"] <- as.date(as.character(data[,"admission"]),order="dmy")
	data[,"onset"] <- as.date(as.character(data[,"onset"]),order="dmy")
	data[,"arrival"] <- as.date(as.character(data[,"arrival"]),order="dmy")
	
	data <- cbind(data,imponset=rep(FALSE,norecs))
	data <- cbind(data,impimp=rep(FALSE,norecs))
	
	# Extra things for Max and Eric
	data <- cbind(data,maxclass=rep(FALSE,norecs))
	data <- cbind(data,maxonset=rep(NA,norecs))
	data <- cbind(data,maxonreport=data$conf_date-as.date("1Jan2009")+1)
	
	for (i in 1:norecs) {
		
		# Clean onset and import class
		if (is.na(data$onset[i])) data$imponset[i] <- TRUE
		if (!is.na(data$onset[i])) data$maxonset[i] <- data$onset[i]-as.date("1Jan2009")+1
		
		# Define age classes
		tmp <- data$age[i]
		if (is.na(tmp) || tmp < 0) data$ageclass[i] <- "NK"
		else if (tmp < 12) data$ageclass[i] <- "01yc"
		else if (tmp < 19) data$ageclass[i] <- "02oc"
		else if (tmp < 54) data$ageclass[i] <- "03ya"
		else if (tmp < 110) data$ageclass[i] <- "04oa"
		else stop("Problem with age allocation")
		
		# define age class 2
		tmp <- data$age[i]
		if (is.na(tmp) || tmp < 0) data$ageclass[i] <- "NK"
		else if (tmp < 12) data$ageclass2[i] <- "y"
		else if (tmp < 19) data$ageclass2[i] <- "o"
		else if (tmp < 110) data$ageclass2[i] <- "a"
		else stop("Problem with age allocation")
		
		# define simp import classes
		tmp <- data$class[i]
		if (tmp %in% c("Imported")) data$simpimp[i] <- "Imported"
		else if (tmp %in% c("Linked","NotLinked")) data$simpimp[i] <- "NotImported"
		else if (tmp %in% c("")) {
			data$simpimp[i] <- "NK"
			data$impimp[i] <- TRUE
		}
		else stop(paste("Problem with simplified importation class",tmp))
		data$ageimpclass[i] <- paste(data$simpimp[i],"_",data$ageclass[i],sep="")
		
		# define simp import classes
		tmp <- data$class[i]
		if (tmp %in% c("Imported")) data$maxclass[i] <- 2
		else if (tmp %in% c("","Linked","NotLinked","Undetermined")) data$maxclass[i] <- 1
		else stop("Problem with max's importation class")
		
	}
	
	data
	
}

AddZeros1DTable <- function(tab) {
	days <- as.numeric(names(tab))
	start <- min(days)
	end <- max(days)
	rtn <- vector(mode="numeric",length=end-start+1)
	for (d in start:end) {
		lookup <- match(d,days)
		if (is.na(lookup)) rtn[d-start+1] <- 0
		else rtn[d-start+1] <- tab[lookup]
	}
	list(days=start:end,vals=rtn)
}

MatrixWithZeroRows <- function(tab) {
	
	# Assumes row names are integers and adds zero rows
	
	maxday <- max(as.numeric(row.names(tab)))
	minday <- min(as.numeric(row.names(tab)))
	nodays <- maxday - minday + 1
	
	rtn <- matrix(data=0,nrow=nodays,ncol=dim(tab)[2])
	
	for (day in minday:maxday) 
		if (as.character(day) %in% row.names(tab)) 
			rtn[day-minday+1,] <- tab[as.character(day),]
	
	rtn
	
}

SimModel <- function(matNGM,matSeed,vecPop,vecParams) {
	
	# Take a set of seeds of different types by onset day and simulates an outbreak
	# Define input and output. Next generation matrix defined such that m[i,j] is the 
	# expected number of type j generated by one of type i.
	
	# To be used for the white-style model
	
	nodays <- dim(matSeed)[1]
	notypes <- dim(matSeed)[2]
	
	# Loop to generate infectious contacts on a given future day
	rtn <- matSeed
	rtn[] <- NA
	
	for (i in 1:notypes) {
		for (j in 1:nodays) {
			
		}
	}
	
	rtn
	
}

FigDataOnsetSeedLocal <- function(	filename, 
		matrix,setscolstop=c(c(1),c(2,3)),
		setscolsbot=c(c(1),c(2,3)),
		colors=c("red","blue"),
		widthcm=10,
		heightcm=10) {
	
	# Make figure 2B
	# - Assumes that ventilation.r has been run
	# - who made the 
	
	# browser()
	
	cwidth 	<- widthcm
	cheight <- heightcm
	
	pdf(filename, width=cwidth/cm(1), height=cheight/cm(1))
	
	# Gaps
	g1 <- 2.5 
	g2 <- 2.5
	g3 <- 0.25
	g4 <- 0.25
	
	xdates <- c("27Apr2009","4May2009","11May2009","18May2009","25May2009",
			"1Jun2009","8Jun2009","15Jun2009","22Jun2009")
	
	axticks <- as.date(xdates)
	axstart <- min(axticks)
	axend	<- max(axticks)
	axnames	<- c("1","2","3","4","5","6","7","8")
	ytickv	<- c(0,10,20,30,40,50)
	ytickn	<- ytickv
	ymax 	<- max(ytickv)
	ytickvB	<- c(0,10,20,30,40,50)
	yticknB	<- ytickvB 
	ymaxB 	<- max(ytickvB)
	lineylab <- 3.75
	
	# browser()
	
	# Spaces for the plots
	A <- (cwidth - g1 - g3)  
	B <- (cheight - g2 - 2*g4) / 2 
	
	# Positions of the different parts
	posA <- c(g1/cwidth,(g1+A)/cwidth,(g2+B+g4)/cheight,(g2+2*B+g4)/cheight)
	posB <- c(g1/cwidth,(g1+A)/cwidth,g2/cheight,(g2+B)/cheight)
	
	# Parameter settings for all parts of the figure
	par(cex=0.8)
	par(mgp=c(2.5,1,0))
	# par(tcl=0.25)
	par(mai=(c(0,0,0,0)))
	par(cex.axis=0.9)
	
	# Part A 
	par(fig=posA)
	
	plot(	1:2,
			type="n",
			axes=FALSE,
			xlim=c(axstart,axend),
			ylim=c(0,ymax))
	
	axis(2,las=1,at=ytickv,labels=ytickn)
	mtext("Incidence",side=2,line=lineylab)
	axis(1,at=axticks,labels=rep("",length(axticks)))
	text(axstart,max(ytickv),"A",font=2,adj=c(0,1))
	
	legend(as.date("15May2009"),max(ytickv)*3/4,
			c(		"> 54",
					"19 - 54",
					"< 19"),
			lty=c(1,1,1),
			lwd=c(8,8,8),
			col=c("blue","green","red"),
			cex=0.75, 
			bty="n",
	)
	
	# Part B 
	par(fig=posB,new=TRUE)
	
	plot(	1:2,
			type="n",
			axes=FALSE,
			xlim=c(axstart,axend),
			ylim=c(0,ymaxB))
	
	axis(2,las=1,at=ytickvB,labels=yticknB)
	mtext("Prevalence",side=2,line=lineylab)
	mtext("(per 100,000)",side=2,line=lineylab-1)
	axis(1,at=axticks,labels=rep("",length(axticks)),las=3)
	
	text(axstart,max(ytickvB),"B",font=2,adj=c(0,1))
	
	dev.off()
	
}

LikePoissonOnsetReport <- function(ps,vecOnsets,vecReports,vecImputes) {
	rtn <- 0
	mu <- ps[1]
	novals <- length(vecOnsets)
	for (i in 1:novals) {
		if (!vecImputes[i]) rtn <- rtn + dpois(vecReports[i]-vecOnsets[i],mu,log=TRUE)
		if (rtn < -1e100 || rtn > 1e100) browser()
	}
	rtn
}

ImputeOnsets <- function(mu,vecImputes,vecReports,vecOnsets) {
	noPoints <- length(vecImputes)
	rtn <- vecOnsets
	for (i in 1:noPoints) if (vecImputes[i]) rtn[i] <- vecReports[i]-rpois(1,mu)
	rtn
}

ImputeImport <- function(p_imp,vecImputes,vecSimpimp) {
	noPoints <- length(vecImputes)
	rtn <- vecSimpimp
	for (i in 1:noPoints) if (vecImputes[i]) {
			if (runif(1) < p_imp) rtn[i] <- "Imported"
			else rtn[i] <- "NotImported"
		}
	rtn
}

HKLikeInc <- function(pvec,inc) {
	nodays <- length(inc)
	rtn <- sum(dpois(inc,pvec["A"]*exp(pvec["r"]*((1:nodays)-1)),log=TRUE))
	rtn
}

lambda_U <- function(t,p,v) {
	if (t < p["tc_U"]) R0 <- p["R0_U1"]
	else R0 <- p["R0_U2"]
	rtn <- R0/p["D_I"]*(v["I_MU"]+v["I_UU"])/(p["N_U"]-p["P_U"]*p["N_T"]*p["D_S"])
	rtn
}

lambda_M <- function(t,p,v) {
	if (t < p["tc_M"]) R0 <- p["R0_M1"]
	else R0 <- p["R0_M2"]
	rtn <- R0/p["D_I"]*(v["I_MM"]+v["I_UM"])/(p["N_M"]-(1-p["P_U"])*p["N_T"]*p["D_S"])
	rtn
}

likeInc <- function(pvec,freqtab,firstbin=18,lastbin=27) {
	starttime 	<- freqtab$lb[firstbin-1]
	rtn <- 0
	for (i in firstbin:lastbin) {
		rtn <- rtn + dpois(freqtab$f[i],pvec["A"]*exp(pvec["r"]*(freqtab$lb[i]-starttime)),log=TRUE)
	}
	rtn
}

postProcLineList <- function(td,order="dmy",ageclass=10) {
	
	setinclude 	<- c(	"Arizona Case","CONFIRMED Colorado Case","Confirmed","PROBABLE",
			"Probable","confirmed","probable","CONFRIMED","P")
	
	td 	<- td[td$CaseStatus %in% setinclude,]
	
	norecords <- dim(td)[1]
	
	rtn <- as.data.frame(cbind(
					cleanOnset=rep(0,norecords),
					cleanInitialReportDate=rep(0,norecords),
					cleanHospPres=rep(0,norecords),
					cleanHosp=rep(0,norecords),
					cleanICU=rep(0,norecords),
					cleanOnsetWk=rep(0,norecords),
					cleanContact=rep(0,norecords),
					cleanAge=rep(0,norecords),
					cleanAG=rep(0,norecords),
					cleanAG2=rep(0,norecords),
					cleanAgeClass=rep(0,norecords),
					cleanMexTrav=rep(0,norecords)
			))
	
	for (i in 1:norecords) {
		
		# Clean up the onset date
		tmp <- as.date(as.character(td$Onset[i]),order=order)
		if (is.na(tmp)) rtn$cleanOnset[i] <- 0
		else rtn$cleanOnset[i] <- tmp
		
		# Some obvious manual corrections should be wihtout "as.date" in the if condition
		if (rtn$cleanOnset[i]==as.date("5Jan2009")) rtn$cleanOnset[i] 	<- as.date("1May2009")
		if (rtn$cleanOnset[i]==as.date("5Feb2009")) rtn$cleanOnset[i] 	<- as.date("2May2009")
		if (rtn$cleanOnset[i]==as.date("5Mar2009")) rtn$cleanOnset[i] 	<- as.date("3May2009")
		if (rtn$cleanOnset[i]==as.date("24Feb2009")) rtn$cleanOnset[i] 	<- 0
		if (rtn$cleanOnset[i]==as.date("27Apr3009")) rtn$cleanOnset[i] 	<- as.date("27Apr2009")
		if (rtn$cleanOnset[i]==as.date("25Apr2029")) rtn$cleanOnset[i] 	<- as.date("25Apr2009")
		if (rtn$cleanOnset[i]==as.date("9Apr2025")) rtn$cleanOnset[i] 	<- as.date("27Apr2009")
		if (rtn$cleanOnset[i]==as.date("9Apr2027")) rtn$cleanOnset[i] 	<- as.date("25Apr2009")
		if (rtn$cleanOnset[i]==as.date("5Apr2009")) rtn$cleanOnset[i] 	<- as.date("4May2009")
		if (rtn$cleanOnset[i]==as.date("5Jan1909")) rtn$cleanOnset[i] 	<- as.date("1May2009")
		if (rtn$cleanOnset[i]==as.date("22Apr1909")) rtn$cleanOnset[i] 	<- as.date("22Apr2009")
		if (rtn$cleanOnset[i]==as.date("24Apr1909")) rtn$cleanOnset[i] 	<- as.date("24Apr2009")
		if (rtn$cleanOnset[i]==as.date("1May1909")) rtn$cleanOnset[i] 	<- as.date("1May2009")
		if (rtn$cleanOnset[i]==-18506) rtn$cleanOnset[i] 	<- as.date("2May2009")
		if (rtn$cleanOnset[i]==15826) rtn$cleanOnset[i] 	<- as.date("2May2009")
		if (rtn$cleanOnset[i]==18053) rtn$cleanOnset[i] <- as.date("6May2009")
		if (rtn$cleanOnset[i]==18083) rtn$cleanOnset[i] <- as.date("7May2009")
		if (rtn$cleanOnset[i]==18114) rtn$cleanOnset[i] <- as.date("8May2009")
		if (rtn$cleanOnset[i]==18145) rtn$cleanOnset[i] <- as.date("9May2009")
		if (rtn$cleanOnset[i]==18174) rtn$cleanOnset[i] <- 0
		if (rtn$cleanOnset[i]==18175) rtn$cleanOnset[i] <- as.date("10May2009")
		
		# Enter the weekstart value
		if (rtn$cleanOnset[i] != 0) {
			rtn$cleanOnsetWk[i] <- rtn$cleanOnset[i] - (rtn$cleanOnset[i] - as.date("5Jan2009")) %% 7 
		} else {
			rtn$cleanOnsetWk[i] <- 0
		}
		
		# Clean up the date of report
		tmp <- as.date(as.character(td$InitialReportDate[i]))
		if (is.na(tmp)) rtn$cleanInitialReportDate[i] <- 0
		else rtn$cleanInitialReportDate[i] <- tmp
		if (rtn$cleanInitialReportDate[i]==as.date("5Jun2009")) rtn$cleanInitialReportDate[i] 	<- as.date("6May2009")		
		
		# Allocate hospitalized status
		tmp <- trimSpace(as.character(td$Hospitalized[i]))
		if (tmp %in% 
				c(	"Y","Yes","y","Y 5/3 (discharged 5/4)","Y (discharged)",
						"Y (disch)","Y 5/2 (discharged 4/3)","Y ","YES",
						"Yes, Pregnant, MILD illness","Y-readmitted 4/30")) 
			rtn$cleanHosp[i] <- "Y"
		else if (tmp %in% c("N","N(ER)","N (ER)","No","n","NO","NN")) rtn$cleanHosp[i] <- "N"
		else if (tmp %in% c("","U")) rtn$cleanHosp[i] <- "NK" 
		else stop("Encountered a value of Hospitalized that is not recognized >>",tmp,"<< at ",i)
		
		# Allocate ICU status
		tmp <- trimSpace(as.character(td$ICU[i]))
		if (tmp %in% c("Y","Yes")) rtn$cleanICU[i] <- "Y"
		else if (tmp %in% c("N","No","n") || rtn$cleanHosp[i] == "N") rtn$cleanICU[i] <- "N"
		else if (	is.na(tmp) || 
				tmp %in% c("","U","NA","Unknown")) rtn$cleanICU[i] <- "NK" 
		else {
			browser()
			stop("Encountered a value of ICU that is not recognized >>",tmp,"<< at ",i)
		}	
		# Clean contact status
		tmp <- trimSpace(as.character(td$ContactofConfCase[i]))
		if (tmp %in% c("Y","Y ","Yes","Yes, Probable","Y (child of 09V01540)")) rtn$cleanContact[i] <- "Y"
		else if (tmp %in% c("N","No","n")) rtn$cleanContact[i] <- "N"
		else if (tmp %in% c(""," ","U","U ","u","Unknown")) rtn$cleanContact[i] <- "NK" 
		else stop("Encountered a value of clean contact that is not recognized >>",tmp,"<< at ",i)
		
		# Clean Age
		tmp_a <- as.character(td$age[i])
		tmp_d <- as.character(td$dob[i])
		if (!is.na(tmp_a) && tmp_a!="" && !as.numeric(tmp_a) < 0) { 
			rtn$cleanAge[i] <- as.numeric(tmp_a)
		} else {
			tmpdob <- as.date("1Jan2200")
			if (!is.na(as.date(tmp_d,order="dmy"))) tmpdob <- as.date((tmp_d),order="dmy")
			else if (!is.na(as.date(tmp_d,order="mdy"))) tmpdob <- as.date((tmp_d),order="mdy")
			tmponset <- as.date("24Apr2009")
			if (rtn$cleanOnset[i]!= 0) tmponset <- rtn$cleanOnset[i]
			if (tmpdob < tmponset) rtn$cleanAge[i] <- (tmponset - tmpdob) / 365.25
			else rtn$cleanAge[i] <- -1
		}
		
		# Allocate age status
		if (rtn$cleanAge[i] <0) rtn$cleanAG[i] <- "NK"
		else if (rtn$cleanAge[i] < 19) rtn$cleanAG[i] <- "c"
		else if (rtn$cleanAge[i] < 55) rtn$cleanAG[i] <- "a"
		else rtn$cleanAG[i] <- "e"
		rtn$cleanAgeClass[i] <- rtn$cleanAge[i] %/% ageclass
		if (rtn$cleanAge[i] <0) rtn$cleanAG2[i] <- "NK"
		else if (rtn$cleanAge[i] < 5) rtn$cleanAG2[i] <- "00t04"
		else if (rtn$cleanAge[i] < 18) rtn$cleanAG2[i] <- "05t17"
		else if (rtn$cleanAge[i] < 64) rtn$cleanAG2[i] <- "18t64"
		else rtn$cleanAG2[i] <- "64p"
		
		# Clean contact status
		tmp <- trimSpace(as.character(td$TravelMexico[i]))
		if (tmp %in% c("Y","yes","Y (3/27 - 4/3) - Cancun","Y (3/27 - 4/5) - Cancun")) rtn$cleanMexTrav[i] <- "Y"
		else if (tmp %in% c(	"N","n","N (Arizona)","N (Costa Rica)","N (travel to DC)",
				"N (San Francisco)","N (travel to DC)","No","M","N (DC)",
				"N (San Diego 4/13-23)","no")) rtn$cleanMexTrav[i] <- "N"
		else if (tmp %in% c("","U","u","Unknown")) 
			rtn$cleanMexTrav[i] <- "NK" 
		else stop("Encountered a value of cleanMexTrav that is not recognized >>",tmp,"<< at ",i)
		
	}
	
	rtn
	
}

venModel <- function(t,y,p) {
	
	rtn=array(0,c(10))
	names(rtn) 	<- c("S","Ia","Is","Ih","Iv","dS","dIa","dIs","dIh","dIv")
	names(y) 	<- c("S","Ia","Is","Ih","Iv","dS","dIa","dIs","dIh","dIv")
	lambda 		<- p["beta"]*(y["Ia"]+y["Is"])/p["N"]
	rtn["S"] 	<- - lambda*y["S"]
	rtn["Ia"] 	<- lambda*y["S"]*(1-p["p_R"]) - p["gamma"]*y["Ia"]
	rtn["Is"] 	<- lambda*y["S"]*p["p_R"] - p["gamma"]*y["Is"]
	rtn["Ih"] 	<- p["gamma"]*y["Is"]*p["p_H_base"]*(1-p["p_I"]) - p["gamma_h"]*y["Ih"]
	rtn["Iv"] 	<- p["gamma"]*y["Is"]*p["p_H_base"]*p["p_I"] - p["gamma_v"]*y["Iv"]
	
	rtn["dS"] 	<- lambda*y["S"]									# infection incidence
	rtn["dIa"] 	<- lambda*y["S"]*(1-p["p_R"])						# asymptomatic infection incidence
	rtn["dIs"] 	<- lambda*y["S"]*p["p_R"]							# symptomatic infection incidence
	rtn["dIh"] 	<- p["gamma"]*y["Is"]*p["p_H_base"]*(1-p["p_I"])	# hospitalized infection incidence
	rtn["dIv"] 	<- p["gamma"]*y["Is"]*p["p_H_base"]*p["p_I"]		# ventilated case incidence
	rtn["dD"] 	<- p["gamma_v"]*y["Iv"]*p["p_D"]					# incidence death
	
	list(rtn)
	
}

usParams <- function(){
	
	c(		N 			= 1,
			seed 		= 1,
			r 			= 0.26,
			Tg 			= 1.8,
			phi_1		= 2.0,
			phi_2		= 1.0,
			p_R 		= 0.86,
			p_H_base 		= 0.031,
			p_H_base_1 		= 0.02489,
			p_H_base_2 		= 0.03575,
			p_H_base_3 		= 0.09338,
			p_I 		= 0.13,
			p_I_1 		= 0.1364,
			p_I_2 		= 0.1111,
			p_I_3 		= 0.2222,
			gamma_v 	= 1/5.2,									# Gowardman
#			p_I_1 		= 0.1364/2,
#			p_I_2 		= 0.1111/2,
#			p_I_3 		= 0.2222/2,
#			gamma_v 	= 1/9.0,									# Gowardman
			gamma_h 	= 1/7.0,									# Feagan		
			t0 			= as.date("12Apr2009"),
			p_1			= (82640086-21514358/5)/304059724,			# From http://www.census.gov/popest/national/asrh/NC-EST2008-sa.html
			p_2			= (170378099 - 4/5*21514358)/304059724,
			p_3			= 72555897/304059724,
			mixmatindex	= 1
	)
}

modelSIR <- function(pname=NULL,pvals=NULL,venParams=usParams()) {
	
	if (length(pname) != length(pvals)) stop("Error: modelSIR: the two vectors must be the same length")
	
	if (length(pname) > 0) {
		for (i in 1:length(pname)) {
			if (pname[i] %in% names(venParams) == FALSE) stop("Unknown parameter passed to a model SIR")
			else venParams[pname[i]] <- pvals[i] 
		}
	}
	
	venParams["R0"] = 1 + venParams["r"]*venParams["Tg"]
	venParams["gamma"] = 1 / venParams["Tg"]
	
	venParams["S0"] = venParams["N"] - venParams["seed"]
	venParams["Is0"] = venParams["seed"]
	
	venParams["beta"] = venParams["gamma"]*venParams["R0"]	
	initial_conditions <- c(venParams["S0"],0,venParams["Is0"],0,0,0,0,0,0,0,0)
	names(initial_conditions) <- c("S","Ia","Is","Ih","Iv","dS","dIa","dIs","dIh","dIv","dD")
	
	# Debugging from here
	
	no_invals 	<- 364
	no_years 	<- 1
	time_points <- ((0:no_invals)*364*no_years)/no_invals
	timestep 	<- time_points[2]-time_points[1]
	last_index 	<- length(time_points+1)
	
	solution <- lsoda(initial_conditions,time_points,venModel,venParams,atol=1e-80)
	
	solution[1,"dS"] <- 0
	for (i in 2:last_index) solution[i,"dS"] <- (solution[i,"dIs"] - solution[i-1,"dIs"]) / timestep
	
	solution[,"time"] <- solution[,"time"] + venParams["t0"] 
	
	solution
	
}

MixingCAE <- function() {
	
	# Mixing matrix based on the UK data from mossang
	# Age groups here are 0-18, 19-54, 55+
	
	rtn <- t(array(c(	0.58,	0.36,	0.06,
						0.23,	0.63,	0.14,
						0.15,	0.52,	0.33	
					), dim=c(3,3)))
	
	rtn
	
}

MixingCCA <- function() {
	
	# Mixing matrix based on the UK data from mossang
	# Age groups here are 0-11, 12-18, 18+
	
	rtn <- t(array(c(		0.43,	0.10,	0.46,
							0.08,	0.53,	0.39,
							0.09,	0.11,	0.80	
					), dim=c(3,3)))
	
	rtn
	
}

# Scale mixing value
ScaleMixingValueOldOld <- function(val,scale) {val[1,1] + scale * (val - val[1,1])}

ScaleMixingValue <- function(val,scale) {
	val^scale
}

ScaleMixingValueOld <- function(val,scale) {
	nrow <- (dim(val))[1]
	ncol <- (dim(val))[2]
	rtn <- matrix(0,nrow=nrow,ncol=ncol)
	for (i in 1:nrow) {
		for (j in 1:ncol) {
			if (i==j && i==1) rtn[i,j] <- val[i,j]
			else if (val[i,j] > val[1,1]) rtn[i,j] <- val[1,1] + scale * (val[i,j] - val[1,1])
			else rtn[i,j] <- val[1,1] - scale * (val[1,1] - val[i,j])
		}
	}
	if (min(rtn) < 1e-10) stop("Scale vaulues giving negative mixing is not allowed")
	rtn
}


MixingCA3 <- function(scale=1) {
	
	# Mixing matrix based on the UK data from mossang
	# Age groups here are 0-20, 20+
	# Still using three age groups just for convenience
	
	# 7.8	2.15
	# 5.63	8.210909091
	# Up to here
	
	rtn <- t(array(c(		7.8,	2.15,	2.15,
							3.57,	4.10,	4.10,
							3.57,	4.10,	4.10	
	), dim=c(3,3)))
	
	rtn <- ScaleMixingValue(rtn,scale)
	
	rtn
	
}

MixingCCAA <- function() {
	
	# Mixing matrix based on the UK data from mossang
	# Age groups here are as per lipsitch severity, 0-4, 5-17, 18-64, 65+
	
	# These data are worked out from mossong {Mossong, 2008 p01379} in the file
	# age_mixing.xls
	
	# Note that the m=t(array(c(...),dim=(.,.))) gives m[i,j] in the same way that R would print m
	# without the transpose t(.), the i and j are switched
	
	rtn <- t(array(c(
							0.216,	0.198,	0.560,	0.026,
							0.029,	0.585,	0.366,	0.020,
							0.040,	0.173,	0.725,	0.062,
							0.023,	0.151,	0.616,	0.209	
					),c(4,4)))
	
	rtn
	
}

MixingNull <- function() {
	
	# Null mixing matrix
	
	rtn <- t(array(c(	1,		1,		1,
						1,		1,		1,
						1,		1,		1	
					), dim=c(3,3)))
	rtn
	
}

MixingNullFour <- function() {
	
	# Null mixing matrix
	
	rtn <- t(array(c(	1,	1,	1,	1,
						1,	1,	1,	1,
						1,	1,	1,	1
					), dim=c(4,4)))
	
	rtn
	
}

ageVenModel <- function(t,y,p) {
	
	# Set the number of state variables and a "skip" auxilliary variable
	noAges 	<- 3
	noStates <- 6
	noAux 	<- 3 
	skp <- noAux + noStates
	
	# Set up the main return functions
	rtn <- array(0,c(noAges*(noAux+noStates)))
	
	# Generate the normalized mixing matrix
	if (p["mixmatindex"]==1) mixm <- MixingNull()
	else if (p["mixmatindex"]==2) mixm <- MixingCAE()
	else if (p["mixmatindex"]==3) mixm <- MixingCCA()
	else if (p["mixmatindex"]==4) mixm <- MixingCA3(p["mixsense"])
	else stop("Code for mixing matrix not found.")
	
	# Scale beta for sesonality
	if ((t %% 364) > p["dur_seas"]) beta <- p["beta"]*(1-p["amp_seas"])
	else beta <- p["beta"]
	
	# Generate the age specific vector for number of people, probability of hospitalization and probability of being severe
	vecN 	<- p["N"]*array(c(p["p_1"],p["p_2"],p["p_3"])/(p["p_1"]+p["p_2"]+p["p_3"]))
	vecpH	<- array(c(p["p_H_base_1"],p["p_H_base_2"],p["p_H_base_3"]))
	vecpI	<- array(c(p["p_I_1"],p["p_I_2"],p["p_I_3"]))
	vecPhi 	<- array(c(p["phi_1"],p["phi_2"],p["phi_3"]))
	
	# browser()
	
	# If aging turned on, generate the aging in and aging out terms for each state
	ageing <- matrix(0,nrow=noAges,ncol=noStates)
	if (p["aging_on"]==1) {
		ageing[1,1] 		<- c(	p["mu_3"]*sum(y[((3-1)*skp+1):((3-1)*skp+6)]) - p["mu_1"]*y[(1-1)*skp+1])
		ageing[1,2:noAges] 	<- - p["mu_1"]*y[(1-1)*skp+2:noAges]
		ageing[2,1:noAges]	<- + p["mu_1"]*y[(1-1)*skp+1:noAges] - p["mu_2"]*y[(2-1)*skp+1:noAges]
		ageing[3,1:noAges]	<- + p["mu_2"]*y[(2-1)*skp+1:noAges] - p["mu_3"]*y[(3-1)*skp+1:noAges]
	}
	
	# Start the main loop
	for (i in 1:noAges) {
		
		# Set the force of infection to zero and start a loop through j infecting classes
		lambda <- 0
		for (j in 1:noAges) {
			
			# Each j class mixes a proportion minm[i,j] of its time with the i class
			# (j-1)*skp+2 and (j-1)*skp+3] pick out the infectious classes
			lambda <- lambda + 	mixm[i,j]*(y[(j-1)*skp+2]+y[(j-1)*skp+3]) / vecN[j] 
			
		}
		
		# The force of infection is adjusted according to the susceptibility of the ith class
		# Different ngm matrices require different parameterizations
		lambda <- lambda *  beta * vecPhi[i]
		
		# Eqn for susceptibles
		rtn[(i-1)*skp+1]	<- -(lambda*y[(i-1)*skp+1]+p["trickle"]/3) + p["gamma_R"]*y[(i-1)*skp+6] + ageing[i,1]
		
		# Eqn for asymp infections
		rtn[(i-1)*skp+2]	<- (lambda*y[(i-1)*skp+1]+p["trickle"]/3)*(1-p["p_R"]) - p["gamma"]*y[(i-1)*skp+2] + ageing[i,2]
		
		# Eqn for symp infections
		rtn[(i-1)*skp+3]	<- (lambda*y[(i-1)*skp+1]+p["trickle"]/3)*p["p_R"] - p["gamma"]*y[(i-1)*skp+3] + ageing[i,3]
		
		# Eqn for hosp normal ward
		rtn[(i-1)*skp+4]	<- p["gamma"]*y[(i-1)*skp+3]*vecpH[i]*(1-vecpI[i]) - p["gamma_h"]*y[(i-1)*skp+4] + ageing[i,4]
		
		# Eqn for hosp ICU ward
		rtn[(i-1)*skp+5]	<- p["gamma"]*y[(i-1)*skp+3]*vecpH[i]*vecpI[i] - p["gamma_v"]*y[(i-1)*skp+5] + ageing[i,5]
		
		# Eqn for recovered
		rtn[(i-1)*skp+6]	<- p["gamma_v"]*y[(i-1)*skp+5] + p["gamma_h"]*y[(i-1)*skp+4] + 
									p["gamma"]*y[(i-1)*skp+3]*(1-vecpH[i]) + p["gamma"]*y[(i-1)*skp+2] - 
									p["gamma_R"]*y[(i-1)*skp+6] + ageing[i,6]
		
		# infection incidence
		rtn[(i-1)*skp+7] 	<- lambda*y[(i-1)*skp+1]							
		
		# asymptomatic infection incidence
		rtn[(i-1)*skp+8] 	<- lambda*y[(i-1)*skp+1]*(1-p["p_R"])
		
		# symptomatic infection incidence
		rtn[(i-1)*skp+9] 	<- lambda*y[(i-1)*skp+1]*p["p_R"]
		
	}
	
	# if (t>500) browser()
	
	list(rtn)
	
}

ageVenModelFour <- function(t,y,p) {
	
	# Set the number of state variables and a "skip" auxilliary variable
	noAges 	<- 4
	noStates <- 5
	noAux 	<- 4 
	skp <- noAux + noStates
	
	# Set up the main return functions
	rtn <- array(0,c(noAges*(noAux+noStates)))
	
	# Generate the normalized mixing matrix
	if (p["mixmatindex"]==1) mixm <- MixingNullFour()
	else if (p["mixmatindex"]==2) mixm <- MixingCCAA()
	else stop("Code for mixing matrix not found for ageVenModelFour.")
	
	# Implement school holidays reduction in transmission
	if ((t + p["t0"]) > p["t_st"]) mixm[2,2] <- mixm[2,2] * p["delta_sm"] 
	
	# Generate the age specific vector for number of people, probability of hospitalization and probability of being severe
	vecN 	<- p["N"]*array(c(p["p_1"],p["p_2"],p["p_3"],p["p_4"])/(p["p_1"]+p["p_2"]+p["p_3"]+p["p_4"]))
	vecpH	<- array(p["p_H_base"]*c(p["p_H_base_1"],p["p_H_base_2"],p["p_H_base_3"],p["p_H_base_4"]))
	vecpI	<- array(c(p["p_I_1"],p["p_I_2"],p["p_I_3"],p["p_I_4"]))
	vecPhi	<- array(c(p["phi_1"],p["phi_2"],p["phi_3"],p["phi_4"]))
	
	# Start the main loop
	for (i in 1:noAges) {
		
		# Set the force of infection to zero and start a loop through j infecting classes
		lambda <- 0
		for (j in 1:noAges) {
			
			# Each j class mixes a proportion minm[i,j] of its time with the i class
			# (j-1)*skp+2 and (j-1)*skp+3] pick out the infectious classes
			lambda <- lambda + 	mixm[i,j]*(y[(j-1)*skp+2]+y[(j-1)*skp+3]) / vecN[j] 
			
		}
		
		# The force of infection is adjusted according to the susceptibility of the ith class
		lambda <- lambda * p["beta"] * vecPhi[i]	
		
		# Eqn for susceptibles
		rtn[(i-1)*skp+1]	<- - lambda*y[(i-1)*skp+1]
		
		# Eqn for asymp infections
		rtn[(i-1)*skp+2]	<- lambda*y[(i-1)*skp+1]*(1-p["p_R"]) - p["gamma"]*y[(i-1)*skp+2]
		
		# Eqn for symp infections
		rtn[(i-1)*skp+3]	<- lambda*y[(i-1)*skp+1]*p["p_R"] - p["gamma"]*y[(i-1)*skp+3]
		
		# Eqn for hosp normal ward
		rtn[(i-1)*skp+4]	<- p["gamma"]*y[(i-1)*skp+3]*vecpH[i]*(1-vecpI[i]) - p["gamma_h"]*y[(i-1)*skp+4]
		
		# Eqn for hosp ICU ward
		rtn[(i-1)*skp+5]	<- p["gamma"]*y[(i-1)*skp+3]*vecpH[i]*vecpI[i] - p["gamma_v"]*y[(i-1)*skp+5]
		
		# infection incidence
		rtn[(i-1)*skp+6] 	<- lambda*y[(i-1)*skp+1]							
		
		# asymptomatic infection incidence
		rtn[(i-1)*skp+7] 	<- lambda*y[(i-1)*skp+1]*(1-p["p_R"])
		
		# symptomatic infection incidence
		rtn[(i-1)*skp+8] 	<- lambda*y[(i-1)*skp+1]*p["p_R"]

		# ICU incidence
		rtn[(i-1)*skp+9] 	<- p["gamma"]*y[(i-1)*skp+3]*vecpH[i]*vecpI[i]	
		
	}
	
	list(rtn)
	
}

MakeNgm <- function(mix,params,vecN) {
	
	# Returns a next generation matrix with variable susceptibility by age group 
	# Designed for multiple levels of mixing
	
	rtn <- 1/params["gamma"]*t(array(c(	
							params["phi_1"]*mix[1,1],					params["phi_1"]*(vecN[1]*mix[1,2]/vecN[2]),	params["phi_1"]*(vecN[1]*mix[1,3]/vecN[3]),
							vecN[2]*mix[2,1]/vecN[1],					mix[2,2],									vecN[2]*mix[2,3]/vecN[3],
							params["phi_2"]*(vecN[3]*mix[3,1]/vecN[1]),	params["phi_2"]*(vecN[3]*mix[3,2]/vecN[2]),	params["phi_2"]*(mix[3,3])
					), dim=c(3,3)))
	rtn
}

MakeNgmFour <- function(mix,params,vecN) {
	
	# Returns a next generation matrix with variable susceptibility by age group 
	# Designed for multiple levels of mixing
	
	rtn <- 1/params["gamma"]*t(array(c(	
							params["phi_1"]*mix[1,1],					params["phi_1"]*vecN[1]*mix[1,2]/vecN[2],	params["phi_1"]*vecN[1]*mix[1,3]/vecN[3],				params["phi_1"]*vecN[1]*mix[1,4]/vecN[4],
							params["phi_2"]*vecN[2]*mix[2,1]/vecN[1],	params["phi_2"]*mix[2,2],					params["phi_2"]*vecN[2]*mix[2,3]/vecN[3],			params["phi_2"]*vecN[2]*mix[2,4]/vecN[4],
							params["phi_3"]*vecN[3]*mix[3,1]/vecN[1],	params["phi_3"]*vecN[3]*mix[3,2]/vecN[2],	params["phi_3"]*mix[3,3],														params["phi_3"]*vecN[4]*mix[3,4]/vecN[4],
							params["phi_4"]*vecN[4]*mix[4,1]/vecN[1],	params["phi_4"]*vecN[4]*mix[4,2]/vecN[2],	params["phi_4"]*vecN[4]*mix[4,3]/vecN[3],			params["phi_4"]*mix[4,4]
					), dim=c(4,4)))
	
	rtn
}

likeSusEigen <- function(vecS,params,vecN,mix,cm,ngm) {
	
	# Likelihood function for different susceptibilities given mixing matrix and observed infections
	
	if (vecS[1] < 0 || vecS[2] < 0) rtn <- -1e100
	else {
		params["gamma"] <- 1
		params["phi_1"] <- vecS[1]
		params["phi_2"] <- vecS[2]
		params["phi_3"] <- 1
		mG <- ngm(mix,params,vecN)
		ev  <- Re(eigen(mG)$vector[,1])
		if (ev[1] < 0) ev <- ev * -1
		rtn <- dmultinom(cm,prob=ev,log=TRUE)
	}
	rtn
}

likeSusEigenFour <- function(vecS,params,vecN,mix,cm,ngm) {
	
	# Likelihood function for different susceptibilities given mixing matrix and observed infections
	
	if (vecS[1] < 0 || vecS[2] < 0 || vecS[3] < 0) rtn <- -1e100
	
	else {
		
		params["gamma"] <- 1
		params["phi_1"] <- vecS[1]
		params["phi_2"] <- vecS[2]
		params["phi_3"] <- vecS[3]
		params["phi_4"] <- 1
		mG 	<- ngm(mix,params,vecN)
		ev  <- Re(eigen(mG)$vector[,1])
		if (ev[1] < 0) ev <- ev * -1
		rtn <- dmultinom(cm,prob=ev,log=TRUE)
		
	}
	
	rtn
	
}

SirModel3AgeClasses <- function(pname=NULL,pvals=NULL,casemix=c(1,1,1),vp=usParams(),NGM=MakeNgm) {
	
	# Calling function for the age structured ode model
	# Returns table of all the useful output variables
	# pname is a list of parameter names to change
	# pvals is the list of values to assigne to them
	# case mix is the proportion of individuals in each age class
	# vp is the parameter set to be used
	# NGM is the function to be used to make the next generation matrix
	
	# Check that the length of pname is the same as that of pvec
	if (length(pname) != length(pvals)) stop("Error: modelSIR: the two vectors must be the same length")
	
	# Add some extra parameters which are fully constrained by the other parameters
	# Allow only r or R0 to be present, not both
	if (!is.na(vp["R0"]) && !is.na(vp["r"])) stop("Both R0 and r cannot be specified in this model")
	if (is.na(vp["R0"]) && !is.na(vp["r"])) vp["R0"] = 1 + vp["r"]*vp["Tg"]
	
	# For non-null parameter vectors, change the appropriate parameters
	if (length(pname) > 0) {
		for (i in 1:length(pname)) {
			if (pname[i] %in% names(vp) == FALSE) stop("Unknown parameter passed to a model SIR")
			else vp[pname[i]] <- pvals[i] 
		}
	}
		
	# rate of recovery
	vp["gamma"] = 1 / vp["Tg"]
	
	# Assign the different mixing matrices based on the value of the appropriate parameter
	if (vp["mixmatindex"]==1) mm <- MixingNull()
	else if (vp["mixmatindex"]==2) mm <- MixingCAE()
	else if (vp["mixmatindex"]==3) mm <- MixingCCA()
	else if (vp["mixmatindex"]==4) mm <- MixingCA3(vp["mixsense"])
	else stop("Code for mixing matrix not found.")
	
	# Set up the population vector for the NGM calcuations
	vecP <- c(vp["p_1"],vp["p_2"],vp["p_3"]) / (vp["p_1"]+vp["p_2"]+vp["p_3"]) 
	vN <- c(vp["N"]*vecP[1],vp["N"]*vecP[2],vp["N"]*vecP[3])
	
	# Obtain the values for relative susceptibility, fitted using the NGM data
	# DEBUG_LINE likeSusEigen(c(2,1,1),vp,vN,mm,casemix,ngm=NGM)

	if (vp["fitsus"]==1) {
		bfSus <- optim(	c(2,1),likeSusEigen,control=list(trace=0,fnscale=-1,maxit=10000),
				params=vp, vecN=vN, mix=mm, cm=casemix, ngm=NGM)			
		vp["phi_1"] <- bfSus$par[1] # 2.2
		vp["phi_2"] <- bfSus$par[2] # 0.34
	}
	
	# Need to assign phi_3 even if not fitting susceptibility
	vp["phi_3"] <- 1
	
	# Browser here to check susceptibility parameters
	# DEBUG_LINE browser()
	
	# Defined the next generation matrix with, implicitly, beta set = 1
	mG <- NGM(mm,vp,vN)
	esol <- eigen(mG)
	
	if (vp["fitsus"]==1) {	
		# Double check that the eigen vector matches that implied used to contrain susceptibility
		evec <- esol$vectors[,1]
		bench <- casemix
		evec <- evec/sum(evec)*sum(bench)
		if (abs(sum(evec-bench)) > 1) stop("Problem matching the eigen vector to initial age-specific incidence") 
	}
	
	# Calculate the eigen values, the real eigen values and then the largest real eigen value
	ev  <- esol$value
	revs <- ev[Im(ev)==0]
	maxrev <- max(Re(revs))
	
	# Define beta using the basic reproductive number and the largest eigen value
	vp["beta"] <- vp["R0"] / maxrev
	
	# Set the initial conditions assuming that the seed is split evenly between age classed
	initial_conditions <- c(
			vN[1]-vp["seed"]/3,0,vp["seed"]/3,0,0,0,0,0,0,
			vN[2]-vp["seed"]/3,0,vp["seed"]/3,0,0,0,0,0,0,
			vN[3]-vp["seed"]/3,0,vp["seed"]/3,0,0,0,0,0,0	)
	
	# Define the names for the output variables
	vecnames <- c()
	for (i in 1:3) vecnames <- c(vecnames,
				paste(	c("S","Ia","Is","Ih","Iv","R","dS","dIa","dIs"),i,sep="")	)
	names(initial_conditions) <- vecnames
	
	# Set run parameters for the model
	no_invals 	<- vp["nodts"]
	no_years 	<- vp["noyears"]
	time_points <- ((0:no_invals)*364*no_years)/no_invals
	timestep 	<- time_points[2]-time_points[1]
	last_index 	<- length(time_points+1)
	
	# Solve the differential equations
	# browser()
	solution <- lsoda(initial_conditions,time_points,ageVenModel,vp,atol=1e-80)
	
	# Add some auxilliary variables and calculate their values
	solution <- cbind(solution, 
			dS 				= rep(NA,length(time_points)),
			dI1 			= rep(NA,length(time_points)),
			dI2 			= rep(NA,length(time_points)),
			dI3 			= rep(NA,length(time_points)),
			Iv 				= rep(NA,length(time_points)),
			Ih 				= rep(NA,length(time_points)),
			N1 				= rep(NA,length(time_points)),
			N2 				= rep(NA,length(time_points)),
			N3 				= rep(NA,length(time_points)),
			N 				= rep(NA,length(time_points)))
	
	solution[1,"dI1"] <- 0
	solution[1,"dI2"] <- 0
	solution[1,"dI3"] <- 0
	for (i in 2:last_index) {
		solution[i,"dI1"] <- (solution[i,"dIs1"] - solution[i-1,"dIs1"]) / timestep 
		solution[i,"dI2"] <- (solution[i,"dIs2"] - solution[i-1,"dIs2"]) / timestep 
		solution[i,"dI3"] <- (solution[i,"dIs3"] - solution[i-1,"dIs3"]) / timestep 
	} 	
	solution[,"dS"] <- solution[,"dI1"] + solution[,"dI2"] + solution[,"dI3"]
	for (i in 1:last_index) {
		solution[i,"Iv"] <- solution[i,"Iv1"] + solution[i,"Iv2"] + solution[i,"Iv3"]
		solution[i,"Ih"] <- solution[i,"Ih1"] + solution[i,"Ih2"] + solution[i,"Ih3"]
	}

	solution[,"N1"] <- rowSums(solution[,paste(c("S","Ia","Is","Ih","Iv","R"),c(1),sep="")])
	solution[,"N2"] <- rowSums(solution[,paste(c("S","Ia","Is","Ih","Iv","R"),c(2),sep="")])
	solution[,"N3"] <- rowSums(solution[,paste(c("S","Ia","Is","Ih","Iv","R"),c(3),sep="")])
	solution[,"N"] <- rowSums(solution[,paste(c("N"),1:3,sep="")])
	
	# Debug lines below for tuning demographic parameters
	# browser()
	# plot(solution[,"N"],type="l",ylim=c(0,max(solution[,"N"])))
	# points(solution[,"N1"],type="l",col="red")
	# points(solution[,"N2"],type="l",col="blue")
	# points(solution[,"N3"],type="l",col="green")	
	
	solution[,"time"] <- solution[,"time"] + vp["t0"] 
	
	# Return the solution and the value of the parameters
	list(sol=solution,par=vp)
	
}

SirModelFourAgeClasses <- function(pname=NULL,pvals=NULL,casemix=c(1,1,1,1),vp=usParams(),NGM=MakeNgmFour) {
	
	# Calling function for the age structured ode model, four age class model
	# This probably needs to be called with number of age classes as an argument?
	# Returns table of all the useful output variables
	# pname is a list of parameter names to change
	# pvals is the list of values to assigne to them
	# case mix is the proportion of individuals in each age class
	# vp is the parameter set to be used
	# NGM is the function to be used to make the next generation matrix
	
	# Check that the length of pname is the same as that of pvec
	if (length(pname) != length(pvals)) stop("Error: modelSIR: the two vectors must be the same length")
	
	# For non-null parameter vectors, change the appropriate parameters
	if (length(pname) > 0) {
		for (i in 1:length(pname)) {
			if (pname[i] %in% names(vp) == FALSE) stop("Unknown parameter passed to a model SIR")
			else vp[pname[i]] <- pvals[i] 
		}
	}
	
	# basic reproductive number
	vp["R0"] = 1 + vp["r"]*vp["Tg"]
	
	# rate of recovery
	vp["gamma"] = 1 / vp["Tg"]
	
	# Assign the different mixing matrices based on the value of the appropriate parameter
	if (vp["mixmatindex"]==1) mm <- MixingNullFour()
	else if (vp["mixmatindex"]==2) mm <- MixingCCAA()
	else stop("Code for mixing matrix not found in four age class model.")
	
	# Set up the population vector for the NGM calcuations
	vecP <- c(vp["p_1"],vp["p_2"],vp["p_3"],vp["p_4"]) / (vp["p_1"]+vp["p_2"]+vp["p_3"]+vp["p_4"]) 
	vN <- c(vp["N"]*vecP[1],vp["N"]*vecP[2],vp["N"]*vecP[3],vp["N"]*vecP[4])
	
	if (vp["fitsus"]!=0) {
	
		# Obtain the values for relative susceptibility, fitted using the NGM data
		# likeSusEigen(c(2,1,1),vp,vN,mm,casemix,ngm=NGM)
		bfSus <- optim(	c(2,1,1),likeSusEigenFour,control=list(trace=0,fnscale=-1,maxit=10000),
			params=vp, vecN=vN, mix=mm, cm=casemix, ngm=NGM)			
		vp["phi_1"] <- bfSus$par[1] # 2.2
		vp["phi_2"] <- bfSus$par[2] # 0.34
		vp["phi_3"] <- bfSus$par[3]
		vp["phi_4"] <- 1
	}
	
	# Browser here to check susceptibility parameters
	# DEBUG_LINE browser()
	
	# Defined the next generation matrix with, implicitly, beta set = 1
	mG <- NGM(mm,vp,vN)
	esol <- eigen(mG)
	
	# Double check that the eigen vector matches that implied used to contrain susceptibility
	evec <- esol$vectors[,1]
	bench <- casemix
	evec <- evec/sum(evec)*sum(bench)
	if (vp["fitsus"]!=0 && sum(abs(evec-bench)) > 0.01) stop(sum(abs(evec-bench)),"0.001","Problem matching the eigen vector to initial age-specific incidence") 
	
	# Calculate the eigen values, the real eigen values and then the largest real eigen value
	ev  <- esol$value
	revs <- ev[Im(ev)==0]
	maxrev <- max(Re(revs))
	
	# Define beta using the basic reproductive number and the largest eigen value
	vp["beta"] <- vp["R0"] / maxrev
	
	# Set the initial conditions assuming that the seed is split evenly between age classed
	initial_conditions <- c(
			vN[1]-vp["seed"]/4,0,vp["seed"]/4,0,0,0,0,0,0,
			vN[2]-vp["seed"]/4,0,vp["seed"]/4,0,0,0,0,0,0,
			vN[3]-vp["seed"]/4,0,vp["seed"]/4,0,0,0,0,0,0,
			vN[4]-vp["seed"]/4,0,vp["seed"]/4,0,0,0,0,0,0	)
	
	# Define the names for the output variables
	vecnames <- c()
	for (i in 1:4) vecnames <- c(vecnames,
				paste(	c("S","Ia","Is","Ih","Iv","dS","dIa","dIs","dIv"),i,sep="")	)
	names(initial_conditions) <- vecnames
	
	# Set run parameters for the model
	no_invals 	<- 364
	no_years 	<- 1
	# Adjust here
	# browser() # XXXX editing here
	# rounded_start_day <- round(vp[])
	time_points	<- 0:(round((vp["tf"]-vp["t0"]))+1) 
	# solution[1,"time"] <- solution[1,"time"] + vp["t0"] %% 1 
	
	# time_points <- ((0:no_invals)*364*no_years)/no_invals
	timestep 	<- time_points[2]-time_points[1]
	last_index 	<- length(time_points+1)
	
	# Solve the differential equations
	solution <- lsoda(initial_conditions,time_points,ageVenModelFour,vp,atol=1e-80)
	
	# Add some auxilliary variables and calculate their values
	solution <- cbind(solution, 
			dS 				= rep(NA,length(time_points)),
			dI1 			= rep(NA,length(time_points)),
			dI2 			= rep(NA,length(time_points)),
			dI3 			= rep(NA,length(time_points)),
			dI4 			= rep(NA,length(time_points)),
			Iv 				= rep(NA,length(time_points)),
			Ih 				= rep(NA,length(time_points)),
			dIv 			= rep(NA,length(time_points))
			)
	
	solution[1,"dI1"] <- 0
	solution[1,"dI2"] <- 0
	solution[1,"dI3"] <- 0
	solution[1,"dI4"] <- 0
	
	for (i in 1:last_index) {
		solution[i,"Iv"] <- solution[i,"Iv1"] + solution[i,"Iv2"] + solution[i,"Iv3"] + solution[i,"Iv4"]
		solution[i,"Ih"] <- solution[i,"Ih1"] + solution[i,"Ih2"] + solution[i,"Ih3"] + solution[i,"Ih4"]
		solution[i,"dIv"] <- solution[i,"dIv1"] + solution[i,"dIv2"] + solution[i,"dIv3"] + solution[i,"dIv4"]
	}
	
	for (i in last_index:2) {
		solution[i,"dI1"] <- (solution[i,"dIs1"] - solution[i-1,"dIs1"]) / timestep 
		solution[i,"dI2"] <- (solution[i,"dIs2"] - solution[i-1,"dIs2"]) / timestep 
		solution[i,"dI3"] <- (solution[i,"dIs3"] - solution[i-1,"dIs3"]) / timestep 
		solution[i,"dI4"] <- (solution[i,"dIs4"] - solution[i-1,"dIs4"]) / timestep 
		solution[i,"dIv"] <- (solution[i,"dIv"] - solution[i-1,"dIv"]) / timestep 
	}
	
	solution[,"dS"] <- solution[,"dI1"] + solution[,"dI2"] + solution[,"dI3"] + solution[,"dI4"]
	solution[,"time"] <- solution[,"time"] + round(vp["t0"]) 
	
	# Return the solution and the value of the parameters
	list(sol=solution,par=vp)
	
}

srDailyInc <- function(vecInc,sd=0,ed=10) {
	nobins 	<- (ed - sd) + 1
	inc 	<- vector(mode="numeric",nobins)
	inc[] 	<- 0
	for (i in 1:length(vecInc)) {
		tmp <- vecInc[i]
		if (tmp >= sd && tmp <= ed) {
			inc[tmp - sd + 1] <- inc[tmp - sd + 1] + 1 
		}	
	}
	inc
}

CIsForPlot <- function(vecN, vecn, ratelb=0.00001) {
	
	noObs <- length(vecn)
	if (noObs != length(vecN)) stop("CIsForPlot: Vectors need to be the same size.")
	rtn <- data.frame(pt=rep(NA,noObs),ub=rep(NA,noObs),lb=rep(NA,noObs))
	
	for (i in 1:noObs) {
		
		tmp_n <- vecn[i]
		tmp_N <- vecN[i]
		if (tmp_N >= 1) {
			rtn$pt[i] <- tmp_n / tmp_N
			if (tmp_n == tmp_N) rtn$ub[i] <- 1
			else rtn$ub[i] <- binCINew(tmp_N,tmp_n,0.025,min=0.000001)
			rtn$lb[i] <- binCINew(tmp_N,tmp_n,0.975,min=lbrates)
		}	
		
	}
	
	rtn	
	
}

plotstack <- function(sol,ac,col,var="Iv",mult=1,thresh=1,const=0) {
	
	ts <- dim(sol)[1]
	x <- c(sol[,"time"],rev(sol[,"time"]))
	
	if (ac==1) y <- c((sol[,paste(var,"1",sep="")]),rep(0,ts))
	else if (ac==2) y <- c((sol[,paste(var,"1",sep="")] + sol[,paste(var,"2",sep="")]),rev((sol[,paste(var,"1",sep="")])))
	else if (ac==3) y <- c((sol[,paste(var,"1",sep="")] + sol[,paste(var,"2",sep="")] + sol[,paste(var,"3",sep="")]),rev((sol[,paste(var,"1",sep="")]+sol[,paste(var,"2",sep="")])))
	else stop("Age class not specified.")
	
	polygon(x,y*mult+const,col=col,border=NA)
	
}

agerate <- function(sol,mult=c(1,1,1),thresh=100) {
	ts 	<- dim(sol)[1] 
	rtn <- 		1/ sol[,"dS"] * (
				sol[,"dI1"]*mult[1] +
				sol[,"dI2"]*mult[2] +
				sol[,"dI3"]*mult[3] )
	
	for (i in 1:ts) if (sol[i,"dS"] < thresh) rtn[i] <- NA
	rtn 
	
	
}

SR_BinOptim <- function(p,P,N,n) {
	guess <- pbinom(n,N,p,lower.tail=TRUE)
	rtn <- P-guess
	rtn
}

binCI <- function(vecN,vecn,P,min=0) {
	noObs <- length(vecN)
	rtn <- array(NA,c(noObs))
	for (i in 1:noObs) {
		if (vecN[i] > 0) {
			sol <- uniroot(SR_BinOptim,c(0,1),P=P,N=vecN[i],n=vecn[i])
			if (sol$root > min) rtn[i] <- sol$root
			else rtn[i] <- min
		} else rtn[i] <- min
	}
	rtn
}

binCINew <- function(N,n,P,min=0.000001) {
	rtn <- NA
	if (N>0) {
		if (N==n) n <- n-1
		if (n==0 && P > 0.5) rtn <- min
		else rtn <- (uniroot(SR_BinOptim,c(0,1),P=P,N=N,n=n))$root
	}
	rtn
}

poisLike <- function(vecModTimes, vecModPrevs, vecObsTimes,vecObsPrevs) {
	
	# Takes four vectors.
	# The first two are the same length and are the times and prevalences from the model.
	# The second two are the same size and are the times and prevalances from the observations.
	# The function assumes that the obs arose from poisson distributions with the model mean.
	# NAs in the vector of observed prevalences are ignored.
	# Assumes that every time point in obs is in model, but not vice versa
	# Assumes that times are monotonically increasing
	
	# An epsilpon value for testing equivalence of doubles
	eps <- 1e-10
	
	# Initialize the return value
	rtn <- 0
	
	# Measure the length of the two vectors and initialize the pointer to the current model time
	intNumberMod 	<- length(vecModTimes)
	intNumberObs 	<- length(vecObsTimes)
	intPointerMod 	<- 1
	
	# Start the main loop increment by observation time
	for (i in 1:intNumberObs) {
		dblCurrentObsTime <- vecObsTimes[i]
		while (vecModTimes[intPointerMod] < dblCurrentObsTime) intPointerMod <- intPointerMod + 1
		dblCurrentModTime <- vecModTimes[intPointerMod]
		if (abs(dblCurrentModTime - dblCurrentObsTime) > eps) {
			browser()
			stop("poisLike: Preconditions not satisfied.")
		}
		intCurrentObsPrev <- vecObsPrevs[i]
		dblCurrentModPrev <- vecModPrevs[intPointerMod]
		if (!is.na(intCurrentObsPrev)) {
			if (intCurrentObsPrev < eps && dblCurrentModPrev > eps) stop("poisLike: Zero model prevalence and non-zero observation.")
			rtn <- rtn + dpois(intCurrentObsPrev,dblCurrentModPrev,log=TRUE)
		}
	}
	
	# Return the log "likelihood" 
	rtn	
	
}

PdmSolveLikeV1 <- function(pvals,pname,pbase,casemix,ngm,likefunc,obs) {
	
	# Generate the model solution
	tmp 		<- SirModelFourAgeClasses(pname=pname,pvals=pvals,
						casemix=casemix,vp=pbase,NGM=ngm)		 
	solution 	<- tmp$sol
	endparams	<- tmp$par
	
	ModelTimes <- as.vector(solution[,"time"])
	ModelPrevs <- as.vector(solution[,"Ih"] + solution[,"Iv"])*4380000
	ObsTimes <- obs[,"Date"]
	ObsPrevs <- as.vector(obs[,"Qld_Hosp"])
	
	rtn <- poisLike(ModelTimes,ModelPrevs,ObsTimes,ObsPrevs)
	
	list(like=rtn,sol=solution,par=endparams)
	
}

PdmSolveLikeV2 <- function(pvals,pname,pbase,casemix,ngm,obs) {
	
	# Generate the model solution
	tmp 		<- SirModelFourAgeClasses(pname=pname,pvals=pvals,casemix=casemix,vp=pbase,NGM=ngm)		 
	solution 	<- tmp$sol
	endparams	<- tmp$par
	
	# Define the other variables needed
	incData 	<- obs$inc
	noObs 		<- length(incData)
	incModel 	<- vector(mode="numeric",length=noObs)
	minday 		<- solution[1,"time"] 
	
	for (i in 1:noObs) {
		
		# Extract incidence of ICU from the solution
		incModel[i] <- sum(solution[(obs$date_start[i]-minday+1):(obs$date_finish[i]-minday+1),"dIv"])
	
	}
	
	rtn <- sum(dpois(incData,incModel*5000000,log=TRUE))	
	
	list(like=rtn,sol=solution,par=endparams)
	
}

PdmLikeHKHosp <- function(pvals,pname,pbase,casemix,obs,vecbins,agnames) {
	
	# Generate the model solution
	tmp 		<- SirModelFourAgeClasses(pname=pname,pvals=pvals,casemix=casemix,vp=pbase)		 
	solution 	<- as.data.frame(tmp$sol)
	endparams	<- tmp$par
	
	incModel <- extFourAgeICU(solution,vecbins,agnames)

	rtn <- sum(dpois(obs,incModel,log=TRUE))	
	
	list(like=rtn,sol=solution,par=endparams)
	
}


fnProposeParamUpdates <- function(ptab,fmask=1:(dim(ptab)[1])) {
	
	# Takes biological parameters, a mask which is a list of the parameters
	# being fitted, a table of the fitted parameters and their ranges and
	# the number of parameters to be fitted. 
	# Returns a proposed vector of parameters.
	# Comment in and out bouncing and cyclical boundary conditions
	# for the random walk
	
	bps <- ptab[,"val"]
	rtn <- bps
	nofit <- length(rtn)
	
	for (i in 1:nofit) {
		
		# Set up and transform to unit scale
		rv <- runif(1)
		rv <- (rv-0.5)* ptab[i,"step"]
		x <- bps[fmask[i]]
		x <- SR_to_unit(x,min=ptab[i,"min"],max=ptab[i,"max"],logflag=ptab[i,"log"])
		x <- x + rv
		
		# Bouncing boundary conditons
		# if (x < 0) x <- -x	
		# if (x > 1) x <- 2 - x
		
		# Cyclical boundary conditions
		if (x < 0) x <- 1 + x	
		if (x > 1) x <- x - 1
		
		# Test for errors and return to originl scales
		if (x < 0 || x > 1) stop("problem here")		
		rtn[fmask[i]] <- SR_from_unit(x,min=ptab[i,"min"],max=ptab[i,"max"],logflag=ptab[i,"log"])
		
	}
	
	rtn
}

fnProposeParamUpdatesSingle <- function(ptab,index) {
	
	# Takes biological parameters, a mask which is a list of the parameters
	# being fitted, a table of the fitted parameters and their ranges and
	# the number of parameters to be fitted. 
	# Returns a proposed vector of parameters.
	# Comment in and out bouncing and cyclical boundary conditions
	# for the random walk
	
	bps <- ptab[,"val"]
	rtn <- bps
	if (index < 0 || index > dim(ptab)[1]) stop("index must be less than or equal to number of parameters")
	
	# Set up and transform to unit scale
	rv <- runif(1)
	rv <- (rv-0.5)* ptab[index,"step"]
	x <- bps[index]
	x <- SR_to_unit(x,min=ptab[index,"min"],max=ptab[index,"max"],logflag=ptab[index,"log"])
	x <- x + rv
		
	# Cyclical boundary conditions
	if (x < 0) x <- 1 + x	
	if (x > 1) x <- x - 1
		
	# Test for errors and return to originl scales
	if (x < 0 || x > 1) stop("problem here")		
	rtn[index] <- SR_from_unit(x,min=ptab[index,"min"],max=ptab[index,"max"],logflag=ptab[index,"log"])
			
	rtn
}

SR_from_unit <- function(x,min=1,max=100,logbase=10,logflag=FALSE) {
	if (logflag) {
		rtn <- min*logbase^(x*(log(max,logbase)-log(min,logbase)))
	} else {
		rtn <- min + (max-min)*x
	}
	rtn
}

SR_to_unit <- function(y,min=1,max=100,logbase=10,logflag=FALSE) {
	if (logflag) {
		rtn <- (log(y,logbase)-log(min,logbase))/(log(max,logbase)-log(min,logbase))
	} else {
		rtn <- (y-min)/(max-min) 
	}
	rtn
}

mcmcH1N1v1 <- function(	fnParams,
						fnOutput,
						params,
						funcLike,
						no_samples=10,
						samp_freq=1,
						report_block=1000,
						tune_block=100,
						tune_min=20,
						tune_max=80,
						tune_factor=2,
						propsingle=TRUE,
						dbgaccept=FALSE,
						...) {
	
	# Set up the mcmc chain
	x 				<- read.csv(fnParams,row.names=1)
	fittedparams 	<- rownames(x)
	no_params 		<- length(fittedparams)
	nosamples 		<- no_samples
	sampfreq		<- samp_freq
	nosamples 		<- nosamples - nosamples %% sampfreq
	norecorded		<- report_block
	nonparheadings	<- c("sample","lnlike")
	nnph			<- length(nonparheadings)
	chain 			<- array(0,dim=c(norecorded,2*length(fittedparams)+nnph))
	colnames(chain) <- c(nonparheadings,fittedparams,paste(fittedparams,"_step",sep=""))
	popvec			<- c(params["p_1"],params["p_2"],params["p_3"],params["p_4"])
	popvecn			<- popvec / sum(popvec)
	
	# Set up tuning characteristics of the main chain
	propcount <- vector(no_params,mode="numeric")
	propcount[]=0
	acceptcount <- vector(no_params,mode="numeric")
	acceptcount[]=0
	
	previoussol <- funcLike(pvals=x[,"val"],pname=fittedparams,pbase=params,...)
	
	lnlike <- previoussol$like
	
	recordno <- 1
	first_write	<- TRUE
	for (i in 0:(nosamples-1)) {
		
		if (i %% sampfreq == 0) {
			chain[recordno,"lnlike"] 	<- lnlike
			chain[recordno,"sample"] 	<- i+1
			chain[recordno,(nnph+1):((nnph+1)+no_params-1)] <- x[,"val"]
			chain[recordno,(nnph+no_params+1):((nnph+1)+2*no_params-1)] <- x[,"step"]
			recordno <- recordno + 1
			if (recordno > norecorded) {
				if (first_write) {
					write.table(chain,file=fnOutput,row.names=FALSE,col.names=TRUE,sep=",",append=FALSE)
					first_write <- FALSE
				} else {
					write.table(chain,file=fnOutput,row.names=FALSE,col.names=FALSE,sep=",",append=TRUE)
				}
				recordno <- 1
			}
		}
		
		chosenparam <- ceiling(runif(1)*no_params)
		prop_x <- fnProposeParamUpdatesSingle(x,chosenparam)
		# prop_x <- fnProposeParamUpdates(x)
	
		
		currentsol <- funcLike(pvals=prop_x,pname=fittedparams,pbase=params,...)
		
		prop_lnlike <- currentsol$like 	
		
		diff_like <- prop_lnlike - lnlike
		
		if (diff_like > 0) accept <- TRUE
		else if (exp(diff_like) > runif(1)) accept <- TRUE
		else accept <- FALSE
		
		propcount[chosenparam] <- propcount[chosenparam]+1
		
		if (accept || dbgaccept) {
			x[,"val"] <- prop_x
			lnlike <- prop_lnlike
			previoussol <- currentsol
			acceptcount[chosenparam] <- acceptcount[chosenparam]+1
		}	
		
		if (propcount[chosenparam]==tune_block) {
			if (acceptcount[chosenparam] < tune_min) x[chosenparam,"step"] <- x[chosenparam,"step"]/tune_factor
			else if (acceptcount[chosenparam] > tune_max) {
				x[chosenparam,"step"] <- x[chosenparam,"step"]*tune_factor
				if (x[chosenparam,"step"] > 1) x[chosenparam,"step"] <- 1
			}
			propcount[chosenparam] <- 0
			acceptcount[chosenparam] <- 0
		}
				
	}
	
	if (recordno > 1) write.csv(chain[1:(recordno-1),],file=fnOutput,row.names=FALSE)
	
}

genMeanMedianCIs <- function(tab,vecnames,conf=c(0.025,0.975)) {
	
	# Examples of input below as used for developing
	# vecnames <- c("a","b")
	# tab <- data.frame(	a=c(1,2,3,4,5,6,7,8,9,10),
	#		b=c(0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,0.1),
	#		c=c(10,20,30,40,50,60,70,80,90,100))
	
	nonames <- length(vecnames)
	for (s in vecnames) if (is.na(match(s,names(tab)))) 
			stop("genStochMeanMedianCIs: vecnames containes a string that's not in tab")
	rtn <- data.frame(mean=rep(0,nonames),median=rep(0,nonames),lb=rep(0,nonames),ub=rep(0,nonames))
	row.names(rtn) <- vecnames
	
	for (s in vecnames) {
		rtn[s,"mean"] 	<- mean(tab[,s])
		quants			<- quantile(tab[,s],probs=c(conf[1],0.5,conf[2]))
		rtn[s,"lb"]		<- quants[1]
		rtn[s,"median"]	<- quants[2]
		rtn[s,"ub"]		<- quants[3]
	}
	
	rtn
	
}

CharToDate <- function(x,order="dmy") {as.date(as.character(x),order=order)}

LoadAndCleanHKSeroInd <- function(filename) {
	
	# reads in the csv file of the participant data from the serosurvey and does
	# any necessary post processing
	
	filename <- "/Volumes/NO NAME/data/influenza/hk_serosurvey/fu_attendence_sr_noident.csv"
	
	rtn <- read.csv(filename)
	
	no_rows <- dim(rtn)[1]
	
	# Fix easy dates
	rtn$base_int_date <- CharToDate(rtn$base_int_date,order="mdy")
	rtn$dob <- CharToDate(rtn$dob,order="mdy")
	
	# Fix recruitment dates for each houehold
	rtn <- cbind(rtn,hh_rec_d=rep(NA,no_rows))
	for (i in 1:no_rows) rtn$hh_rec_d[i] <- FixRecruitmentDate(i,rtn)
	
	# Add age group
	rtn$AG <- rep(1,no_rows)
	for (i in 1:no_rows) {
		tmp <- rtn$dob[i]
		if (!is.na(tmp)) {
			age <- round((as.date("06Jul2009") - tmp) / 365.25)
			if (age > 110 || age < 0) browser() #("problem with age group assignment")
			if (age < 5) rtn$AG[i] <- 2
			else if (age < 19) rtn$AG[i] <- 3
			else if (age < 65) rtn$AG[i] <- 4
			else rtn$AG[i] <- 5
		}
	}
	
	# Let the 
	
	rtn
	
}

LoadAndCleanHKSeroSymp <- function(filename) {
	
	# reads in the csv file of the symptom data from the serosurvey and does
	# any necessary post processing
	# filename <- "/Volumes/NO NAME/data/influenza/hk_serosurvey/fu_symptoms_sr.csv"
	
	rtn <- read.csv(filename)
	rtn$contact_d <- CharToDate(rtn$contact_d)
	rtn$onset_d <- CharToDate(rtn$onset_d)
	rtn
	
}

FixRecruitmentDate <- function(i,tab=c()) {

	# i <- 3
	# tab <- ind_data

	rtn <- 0
	if (!is.na(tab$base_int_date[i])) rtn <- tab$base_int_date[i]
	else {
		for (j in (i-tab$hh_index[i]):(i-tab$hh_index[i]+tab$hh_size[i]-1))
			if (!is.na(tab$base_int_date[j])) rtn <- tab$base_int_date[j]		
	}
	rtn

}

LookUpMain <- function(hh,ind,tab) {
	i <- 1
	max <- dim(tab)[1]
	while (tab$hh_id[i] != hh || tab$hh_index[i] != ind && i <= max) i <- i + 1
	if (i > max) stop("error in LookupMainList")
	i
}

unit_to_log <- function(v,lb,ub) {
	rtnval = lb*10^((log10(ub)-log10(lb))*v)
	rtnval
}

unit_to_linear <- function(v,lb,ub) {
	rtnval = lb + (ub-lb)*v
	rtnval
}

hyper_vector <- function(n,lb,ub,log=FALSE) {
	wk = array(runif(n,0,1),c(n))
	for (i in 1:n) {
		wk[i] = (i-1)/n+wk[i]/n
		if (log) wk[i] = unit_to_log(wk[i],lb,ub) 
		else wk[i] = unit_to_linear(wk[i],lb,ub)
	}
	ranrank = array(runif(n,0,1),c(n))
	index = order(ranrank)
	rtnval = array(0,c(n))
	for (i in 1:n) rtnval[i]=wk[index[i]]
	rtnval
}

procEFlu <- function(filename) {
	
	# Read in the file
	raw <- read.csv(filename)
	
	# Get list of indexes of ever PICU, NICU, ICU
	# index.only.severe <- (raw$hosp.ever.nic == 3) | (raw$hosp.ever.icu == 3)
	index.hosp <- (raw$hosp.ipas.inst.cd != 0) 
	hosp <- raw[index.hosp,] 	# only severe
	noRows <- dim(hosp)[1]
	
	# Make up a matrix of all symptoms and admission date
	# This would be nicer as a list of symptom field strings, but not worth effort and would be slower 
	matSymp <- matrix(nrow=noRows,ncol=12)
	matSymp[,1] <- as.date(as.character(hosp$sym.fever.onset),order="dmy")
	matSymp[,2] <- as.date(as.character(hosp$sym.pneumonia.onset),order="dmy")
	matSymp[,3] <- as.date(as.character(hosp$sym.sore.onset),order="dmy")
	matSymp[,4] <- as.date(as.character(hosp$sym.acute.respiratory.onset),order="dmy")
	matSymp[,5] <- as.date(as.character(hosp$sym.head.onset),order="dmy")
	matSymp[,6] <- as.date(as.character(hosp$sym.myalgia.onset),order="dmy")
	matSymp[,7] <- as.date(as.character(hosp$sym.chills.onset),order="dmy")
	matSymp[,8] <- as.date(as.character(hosp$sym.fatigue.onset),order="dmy")
	matSymp[,9] <- as.date(as.character(hosp$sym.vomit.onset),order="dmy")
	matSymp[,10] <- as.date(as.character(hosp$sym.diarr.onset),order="dmy")
	matSymp[,11] <- as.date(as.character(hosp$sym.other.onset),order="dmy")
	vecAdm <- as.date(as.character(hosp$hosp.adm.dtm),order="dmy")
	vecMinSymp <- apply(cbind(matSymp,vecAdm),1,min,na.rm=TRUE)
	maskTooEarly <- vecMinSymp < 18000
	vecMinSymp[maskTooEarly] <- vecAdm[maskTooEarly]
		
	# Setup the return dataframe
	rtn <- as.data.frame(cbind(
					id  = hosp$patient.key,
					dob = as.date(as.character(hosp$dob),order="dmy"),
					adm = as.date(as.character(hosp$hosp.adm.dtm),order="dmy"),
					dth = (hosp$hosp.dischg.cd == 1),
					sev = (hosp$hosp.ever.nic == 3) | (hosp$hosp.ever.icu == 3),
					first.onset = vecMinSymp))
	
	# Calculate age and assign age groups
	rtn$age <- (rtn$adm - rtn$dob) / 365.25
	for (i in 1:noRows) {
		if (rtn$age[i] > 0 && rtn$age[i] < 5) rtn$ag1[i] <- "1_0t4"
		else if (rtn$age[i] < 18) rtn$ag1[i] <- "2_5t17"
		else if (rtn$age[i] < 65) rtn$ag1[i] <- "3_18t64"
		else if (rtn$age[i] < 110) rtn$ag1[i] <- "4_64plus"
		else {
			browser()
			stop("problem with age group assignemnt 98237492")
		}

		if (rtn$age[i] > 2 && rtn$age[i] < 19) rtn$ag2[i] <- "1_3t18"
		else if (rtn$age[i] < 49) rtn$ag2[i] <- "2_19t48"
		else if (rtn$age[i] < 65) rtn$ag2[i] <- "3_49t64"
		else if (rtn$age[i] < 110) rtn$ag2[i] <- "4_65plus"
		else {
			browser()
			stop("problem with age group assignemnt 298374283")
		}

		if (rtn$age[i] > 2 && rtn$age[i] < 20) rtn$ag20[i] <- "1_3t19"
		else if (rtn$age[i] < 40) rtn$ag20[i] <- "2_20t39"
		else if (rtn$age[i] < 60) rtn$ag20[i] <- "3_40t59"
		else if (rtn$age[i] < 110) rtn$ag20[i] <- "4_60plus"
		else {
			browser()
			stop("problem with age group assignemnt 928374289")
		}

	
	}

	# Designate admission weeks
	# st_w_1 <- as.date("29Dec2008") # start week one. Needs checking
	# rtn$adm.wk <- floor((rtn$adm - st_w_1) / 7)
	
	rtn
	
}

plotDiscInc <- function(matInc,vecBins,vecCols) {
	
	# Puts a plot of rectangles on an alreday established plotting surface
	# to be used for incidence
	
	norows <- dim(matInc)[1]
	noweeks <- dim(matInc)[2]
	nobounds <- length(vecBins)
	
	if (length(vecCols)!=norows) stop("matrix and colour vector don't match in 092384209")
	if (noweeks!=nobounds - 1) stop("matrix and bounds vector don't match in 092384209")
	
	for (i in 1:(nobounds-1)) {
		height <- 0
		for (j in 1:norows) {
			tmpinc <- matInc[j,i]
			if (tmpinc > 0) {
				polygon(	c(vecBins[i],vecBins[i+1],vecBins[i+1],vecBins[i]),
							c(height, height, height+tmpinc, height+tmpinc), col=vecCols[j])
				height <- height + tmpinc
			}
		}
	}
	
}

plotHalfHalf <- function(vecMod,vecData,vecBins,vecUp95=NULL,vecLow95=NULL,color="black",linewidth=0.5) {
	
	# Puts a plot of rectangles on an alreday established plotting surface
	# to be used for individual age category incidences to compare 
	
	noweeks <- length(vecMod)
	nobounds <- length(vecBins)
	
	if (length(vecData)!=noweeks) stop("matrix and colour vector don't match in 092384209")
	if (noweeks!=nobounds - 1) stop("matrix and bounds vector don't match in 092384209")
	
	for (i in 1:(nobounds-1)) {
		datheight <- vecData[i]
		polygon(	c(vecBins[i+1]-(vecBins[i+1]-vecBins[i])/2,vecBins[i+1],vecBins[i+1],vecBins[i+1]-(vecBins[i+1]-vecBins[i])/2),
					c(0, 0, datheight, datheight), col=color, border=color,lwd=linewidth)
	}

	for (i in 1:(nobounds-1)) {
		modheight <- vecMod[i]
		polygon(	c(vecBins[i],vecBins[i+1]-(vecBins[i+1]-vecBins[i])/2,vecBins[i+1]-(vecBins[i+1]-vecBins[i])/2,vecBins[i]),
					c(0, 0, modheight, modheight), col=NA, border="black",lwd=linewidth)
	}
	
}

extFourAgeICU <- function(sol,vecBins,agnames,varnames=c("dIv1","dIv2","dIv3","dIv4")) {
	
	# Extracts incidence of ICU admission from sol
	# Assumes that sol has a time step of one day and that vecBins are evenly spaced
	# agnames are the names of the age groups and there must be four of them
	# assumes that vecBins is at least of length 2 and is montonically increasing
	
	if(abs(sol$time[2]-sol$time[1]-1.0)>1e-10) stop("arg sol must have dt=1")
	
	noagegroups <- length(agnames)
	noWeeks <- length(vecBins)-1
	rtn <- matrix(0,nrow = noagegroups,ncol=noWeeks)
	row.names(rtn) <- agnames
	nosoltimes <- dim(sol)[1]
	
	binsindex <- 1
	maxbinsindex <- length(vecBins)
	eps <- 1e-10
	currentinc <- as.vector(c(0,0,0,0),mode="numeric")
	
	# Need to scroll through solution time
	for (i in 1:(nosoltimes-1)) {
		
		# Assign current time and bin boundaries
		curtime <- sol$time[i]
		curmin <- vecBins[binsindex]
		curmax <- vecBins[binsindex+1]
		
		# If current time falls within the current bin, add the incidence
		if ((curtime > curmin - eps) && (curtime < curmax + eps)) {
			for (j in 1:length(varnames)) {
				rtn[agnames[j],binsindex] <- rtn[agnames[j],binsindex] + sol[i+1,varnames[j]] - sol[i,varnames[j]] 
			}
		} 
		
		# Check what the next time is and update bins index if needed
		nexttime <- sol$time[i+1]
		if (nexttime > (curmax - eps) && (binsindex < maxbinsindex - 1)) binsindex <- binsindex + 1
			
	}
	
	rtn	
	
}

annualmin <- function(ts,noyears,yl=360,incvar="dS",defaultval=1e100) {

	# This function takes output from a standard SR model ts and 
	# calculates the minimum annual incidence for the last noyears
	# of the sample
	# assumes uniform timesteps
	# yl is year length
	# incvar is the variable name for incidence
	
	# browser()
	
	value 	<- vector(mode="numeric",length=noyears)
	value[]	<- defaultval
	
	curind 	<- dim(ts)[1]
	curyear	<- noyears
	curmin	<- 1e100
	dt 		<- ts[curind,"time"] - ts[curind-1,"time"]
	
	nex_yb <- (ts[curind,"time"] %/% yl) * yl

	
	while (curyear >= 1 && curind >= 1) {
		if (ts[curind,incvar] < curmin) curmin <- ts[curind,incvar]
		if (ts[curind,"time"] < nex_yb) {
			value[curyear] <- curmin
			curyear <- curyear - 1
			nex_yb <- (ts[curind,"time"] %/% yl) * yl
			curmin <- 1e100
		}
		curind <- curind - 1
	}
	
	value

}

# Routine to read the used in the CID paper and make equivalent fields
readJoeEFlu <- function(fnFile) {
	
	browser()
	raw <- read.csv(fnFile)
	
	
}